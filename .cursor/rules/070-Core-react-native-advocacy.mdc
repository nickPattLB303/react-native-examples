---
name: "React Native Advocacy Standards"
version: "1.0"
description: "defines the standards and patterns for advocating React Native throughout the course, addressing developer skepticism and building enthusiasm"
priority: "high"
type: "Core"
globs: 
  - "**/*.md"
  - "**/*.js"
  - "**/*.jsx"
  - "**/*.ts"
  - "**/*.tsx"
  - "docs/slides/**/*.html"
triggers:
  - file_change
  - file_open
alwaysApply: true
---

# React Native Advocacy Standards

[README.md](mdc:README.md)
[README.md](mdc:docs/README.md)
[Cursor Rules README](mdc:.cursor/README.md)

## Description
This rule defines the standards and patterns for advocating React Native throughout the course, addressing developer skepticism and building enthusiasm.

## Rule
- All course content must include advocacy elements that market and sell React Native to participants:
  - Each module must include at least one success story
  - Each technical concept must include comparative demonstrations
  - Common skepticism points must be proactively addressed
  - Developer experience benefits must be highlighted
  - The React Native ecosystem must be showcased

- React Native advocacy must follow these core principles:
  - **Honesty**: Acknowledge limitations while demonstrating solutions
  - **Evidence-Based**: Use real-world data and benchmarks
  - **Comparative**: Show clear comparisons with alternatives
  - **Practical**: Focus on practical benefits for developers
  - **Forward-Looking**: Highlight ongoing improvements and roadmap

- Each module must incorporate the following advocacy patterns:

  1. **Comparative Demonstrations**:
     - Show equivalent implementations in native code vs. React Native
     - Highlight code reduction, simplification, and cross-platform benefits
     - Include metrics on development time, maintenance effort, and performance

  2. **Skepticism Addressing Framework**:
     - Acknowledge the concern directly
     - Provide historical/technical context
     - Present evidence that addresses the concern
     - Demonstrate a solution
     - Discuss any remaining tradeoffs honestly

  3. **Success Story Integration**:
     - Include at least one real-world case study per module
     - Focus on companies/applications relevant to participants
     - Provide quantifiable results and metrics
     - Connect the success story to the module's content

  4. **Ecosystem Exploration**:
     - Introduce relevant libraries and tools for each module topic
     - Demonstrate the active community support
     - Show the evaluation criteria for selecting packages
     - Highlight enterprise-ready solutions

  5. **Developer Experience Highlights**:
     - Demonstrate before/after comparisons
     - Quantify time savings and productivity gains
     - Show debugging and testing advantages
     - Highlight cross-platform code sharing benefits

- Module-specific advocacy focus:
  | Module | Advocacy Focus |
  |--------|----------------|
  | Introduction | Overall value proposition and ecosystem overview |
  | Fundamentals | Developer productivity and code reusability |
  | Navigation | Cross-platform consistency with native feel |
  | Data Management | Efficient state management across platforms |
  | API Integration | Seamless backend connectivity |
  | Native Features | Native capabilities without platform-specific code |
  | Performance | Addressing and overcoming performance concerns |
  | Deployment | Streamlined publishing to multiple platforms |

## Examples

### Comparative Demonstration Example:

```javascript
// Native iOS Implementation (Swift)
class MedicationViewController: UIViewController {
    // Complex implementation with multiple files and platform-specific code
    // 30+ lines of code
}

// Native Android Implementation (Kotlin)
class MedicationActivity : AppCompatActivity() {
    // Complex implementation with multiple files and platform-specific code
    // 30+ lines of code
}

// React Native Implementation (JavaScript/JSX)
function MedicationScreen() {
  // Cross-platform implementation in a single file
  // 10-15 lines of code
  return (
    <View style={styles.container}>
      <MedicationList medications={medications} />
    </View>
  );
}
```

### Skepticism Addressing Example:

```markdown
> **Addressing Concerns**: Many developers worry about React Native's performance for animations.
> 
> **Historical Context**: Early versions of React Native did have performance limitations due to the bridge architecture.
> 
> **Current Reality**: With the new architecture and Hermes engine, React Native can achieve near-native performance for most animations.
> 
> **Demonstration**: In this exercise, we'll build a 60fps animation and analyze its performance profile.
> 
> **Consideration**: For extremely complex 3D animations, you might still consider using a native module, which we'll cover in Module 6.
```

### Success Story Example:

```markdown
## Real-World Success: Shopify

**Challenge**: Shopify needed to rebuild their mobile point-of-sale app to support both iOS and Android while maintaining a native feel and high performance.

**Solution**: They chose React Native for its cross-platform capabilities and ability to integrate with native modules when needed.

**Results**:
- Reduced development time by 50% compared to maintaining separate native codebases
- Achieved 95% code sharing between platforms
- Maintained native-level performance for critical operations
- Enabled faster feature deployment across both platforms simultaneously

**Key Takeaway**: React Native allowed a large enterprise to efficiently maintain a complex app across platforms without sacrificing quality or performance.
```

### Developer Experience Example:

```markdown
## Developer Experience Win

**Without React Native**: Implementing a medication list with search functionality

```javascript
// iOS Implementation (Swift)
// 50+ lines of code for TableView setup, delegates, data source
// 30+ lines for search controller implementation
// Separate implementation needed for Android
```

**With React Native**: The same functionality

```javascript
function MedicationList({ medications }) {
  const [searchQuery, setSearchQuery] = useState('');
  const filteredMeds = medications.filter(med => 
    med.name.toLowerCase().includes(searchQuery.toLowerCase())
  );
  
  return (
    <>
      <TextInput
        value={searchQuery}
        onChangeText={setSearchQuery}
        placeholder="Search medications..."
        style={styles.searchInput}
      />
      <FlatList
        data={filteredMeds}
        keyExtractor={item => item.id.toString()}
        renderItem={({ item }) => <MedicationItem {...item} />}
      />
    </>
  );
}
```

**Time Saved**: Approximately 8 hours of development time per platform
``` 