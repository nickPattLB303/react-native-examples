<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Section 3: React Native Internals | React Native Training Course</title>
  <link rel="stylesheet" href="../../shared/styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
  <div class="slides">
    <!-- Title Slide -->
    <section class="slide title-slide">
      <h1>Section 3</h1>
      <h2>React Native Internals</h2>
      <p class="metadata">Module 1 | 30-45 minutes</p>
      <div class="presenter-notes">
        <p><strong>Time Management:</strong> This is the most technical section of the module. If time is limited, focus on the architecture overview and threading model slides, and spend less time on the detailed implementation examples. The key is to ensure participants understand the core concepts rather than all implementation details.</p>
      </div>
    </section>
    
    <!-- Learning Objectives Slide -->
    <section class="slide objectives-slide">
      <h2>Learning Objectives</h2>
      <ul>
        <li>Explain the core architecture of React Native</li>
        <li>Understand how the JavaScript and native threads communicate</li>
        <li>Describe the rendering process from React components to native UI</li>
        <li>Identify the key components of the React Native runtime</li>
      </ul>
    </section>
    
    <!-- Architecture Overview Slide -->
    <section class="slide content-slide">
      <h2>The React Native Architecture</h2>
      <p>To truly understand React Native, we need to look under the hood at its architecture.</p>
      <h3>High-Level Overview</h3>
      <p>At its core, React Native consists of three main parts:</p>
      <ol>
        <li><strong>JavaScript Thread</strong>: Where your React code runs</li>
        <li><strong>Native Threads</strong>: Platform-specific (iOS/Android) threads that handle UI rendering</li>
        <li><strong>Bridge</strong>: The communication layer between JavaScript and native code</li>
      </ol>
      <div class="callout deep-dive">
        <div class="callout-title">Runtime vs Compile-Time</div>
        <p>React Native is not a "compile once, run anywhere" framework like Flutter. Instead, it's a "learn once, write anywhere" framework that uses a runtime bridge to connect JavaScript code with native platform components.</p>
      </div>
    </section>
    
    <!-- Architecture Diagram Slide -->
    <section class="slide content-slide">
      <h2>Architecture Diagram</h2>
      <div style="text-align: center; margin: 20px 0;">
        <pre style="text-align: left; display: inline-block; font-size: 0.9rem;">
┌─────────────────────────┐      ┌─────────────────────────┐
│                         │      │                         │
│    JavaScript Thread    │      │      Native Thread      │
│                         │      │                         │
│  ┌─────────────────┐    │      │    ┌─────────────────┐  │
│  │                 │    │      │    │                 │  │
│  │   React Core    │    │      │    │  Native Modules │  │
│  │                 │    │      │    │                 │  │
│  └────────┬────────┘    │      │    └────────┬────────┘  │
│           │             │      │             │           │
│  ┌────────┴────────┐    │      │    ┌────────┴────────┐  │
│  │                 │    │      │    │                 │  │
│  │  React Native   │    │      │    │   Native UI     │  │
│  │  Components     │    │      │    │   Components    │  │
│  │                 │    │      │    │                 │  │
│  └────────┬────────┘    │      │    └────────┬────────┘  │
│           │             │      │             │           │
└───────────┼─────────────┘      └─────────────┼───────────┘
            │                                  │
            │                                  │
            │        ┌──────────────┐          │
            └────────▶              ◀──────────┘
                     │    Bridge    │
                     │              │
                     └──────────────┘
        </pre>
      </div>
      <div class="callout info">
        <div class="callout-title">Data Flow</div>
        <p>The diagram shows how data and control flow between the JavaScript and native sides of a React Native application, with the bridge serving as the communication channel.</p>
      </div>
    </section>
    
    <!-- JavaScript Thread Slide -->
    <section class="slide content-slide">
      <h2>The JavaScript Thread</h2>
      <p>The JavaScript thread is where most of your application code runs. It includes:</p>
      <ul>
        <li>React Core: The reconciliation engine</li>
        <li>Your application logic</li>
        <li>State management</li>
        <li>Event handling</li>
        <li>Network requests</li>
      </ul>
      <pre><code>
// This code runs in the JavaScript thread
function MedicationScreen() {
  const [medications, setMedications] = useState([]);
  
  useEffect(() => {
    // Network request happens in JS thread
    fetchMedications().then(data => {
      setMedications(data);
    });
  }, []);
  
  return (
    <FlatList
      data={medications}
      renderItem={({ item }) => <MedicationItem medication={item} />}
      keyExtractor={item => item.id.toString()}
    />
  );
}
      </code></pre>
    </section>
    
    <!-- JavaScript Engine Slide -->
    <section class="slide content-slide">
      <h2>JavaScript Engine</h2>
      <p>The JavaScript code runs in a JavaScript engine:</p>
      <div class="columns">
        <div class="column">
          <h3>iOS</h3>
          <ul>
            <li>JavaScriptCore (the Safari JS engine)</li>
            <li>Bundled with the app</li>
            <li>Optimized for mobile</li>
          </ul>
        </div>
        <div class="column">
          <h3>Android</h3>
          <ul>
            <li>JavaScriptCore or Hermes</li>
            <li>Hermes: Facebook's optimized JS engine</li>
            <li>Faster startup, smaller bundle size</li>
          </ul>
        </div>
      </div>
      <div class="platform-web">
        <strong>For Web Developers:</strong> This is similar to how JavaScript runs in a browser, but without DOM manipulation. Instead of updating a DOM, React Native updates a "shadow tree" that then communicates changes to the native side.
      </div>
    </section>
    
    <!-- Native Threads Slide -->
    <section class="slide content-slide">
      <h2>The Native Threads</h2>
      <p>Each platform has its own native threads:</p>
      <div class="columns">
        <div class="column">
          <h3>iOS Native Thread</h3>
          <ul>
            <li>Manages UIKit components</li>
            <li>Handles native module calls</li>
            <li>Renders UI using UIView hierarchy</li>
            <li>Main thread where UI updates occur</li>
          </ul>
        </div>
        <div class="column">
          <h3>Android Native Thread</h3>
          <ul>
            <li>Manages Android UI components</li>
            <li>Handles native module calls</li>
            <li>Renders UI using Android View hierarchy</li>
            <li>Main thread where UI operations take place</li>
          </ul>
        </div>
      </div>
      <div class="platform-ios">
        <strong>For iOS Developers:</strong> Think of this as the main thread in UIKit applications where all UI updates must occur.
      </div>
      <div class="platform-android">
        <strong>For Android Developers:</strong> This is equivalent to the main thread in Android where UI operations must take place.
      </div>
    </section>
    
    <!-- The Bridge Slide -->
    <section class="slide content-slide">
      <h2>The Bridge</h2>
      <p>The bridge is the communication layer between JavaScript and native code. It:</p>
      <ol>
        <li>Serializes data between JavaScript and native code</li>
        <li>Queues and batches messages for efficiency</li>
        <li>Enables asynchronous communication</li>
      </ol>
      <div style="text-align: center; margin: 20px 0;">
        <pre style="text-align: left; display: inline-block;">
JavaScript Thread                Bridge                 Native Thread
┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐
│                 │      │                 │      │                 │
│  React Code     │──────▶ JSON Messages  │──────▶  Native Modules │
│                 │      │                 │      │                 │
└─────────────────┘      └─────────────────┘      └─────────────────┘
        ▲                                                  │
        │                                                  │
        └──────────────────────────────────────────────────┘
                         Callbacks/Events
        </pre>
      </div>
      <div class="callout deep-dive">
        <div class="callout-title">Serialization Process</div>
        <p>The bridge uses a serialization/deserialization process for all communication. Complex objects are converted to JSON strings, sent across the bridge, and then parsed back into objects on the other side. This introduces some overhead, which is why operations that require frequent bridge communication can cause performance issues.</p>
      </div>
    </section>
    
    <!-- Rendering Process Slide 1 -->
    <section class="slide content-slide">
      <h2>The Rendering Process</h2>
      <p>Let's follow what happens when you render a component:</p>
      <h3>1. React Reconciliation</h3>
      <p>When your component's state or props change, React's reconciliation algorithm (also known as the Virtual DOM) determines what needs to update.</p>
      <pre><code>
// State update triggers reconciliation
const [selectedMedication, setSelectedMedication] = useState(null);

// Later in your code
setSelectedMedication(medication); // Triggers React reconciliation
      </code></pre>
      <h3>2. Shadow Tree Updates</h3>
      <p>React Native maintains a "shadow tree" in C++ that mirrors your component hierarchy. After reconciliation, React Native updates this shadow tree.</p>
      <div class="callout deep-dive">
        <div class="callout-title">Shadow Tree</div>
        <p>The shadow tree is a lightweight representation of your UI hierarchy. It's used to calculate layout using a C++ implementation of Flexbox called Yoga. This happens on a separate thread to avoid blocking the main thread.</p>
      </div>
    </section>
    
    <!-- Rendering Process Slide 2 -->
    <section class="slide content-slide">
      <h2>The Rendering Process (continued)</h2>
      <h3>3. Layout Calculation</h3>
      <p>The Yoga layout engine calculates positions and dimensions for all components based on their flexbox properties.</p>
      <pre><code>
// These style properties are processed by the Yoga layout engine
const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'column',
    padding: 16,
  },
  medicationCard: {
    marginBottom: 8,
    borderRadius: 4,
    backgroundColor: '#fff',
  }
});
      </code></pre>
      <h3>4. Native Command Generation</h3>
      <p>Once layout is calculated, React Native generates commands to create and update native views.</p>
      <h3>5. Native UI Updates</h3>
      <p>These commands cross the bridge and are executed on the native thread, updating the actual UI components the user sees.</p>
    </section>
    
    <!-- Rendering Process Slide 3 -->
    <section class="slide content-slide">
      <h2>The Rendering Process (summary)</h2>
      <div style="text-align: center; margin: 30px 0;">
        <div style="font-size: 1.2rem; line-height: 2;">
          React Component → Virtual DOM → Shadow Tree → Layout Calculation → Native Commands → Native Views
        </div>
      </div>
      
      <div style="text-align: center; margin: 20px 0;">
        <pre style="text-align: left; display: inline-block; font-size: 0.9rem; background-color: #f5f5f5; padding: 15px; border-radius: 5px;">
┌─────────────────────────────┐     ┌─────────────────────────────┐
│                             │     │                             │
│      JavaScript Thread      │     │        Native Thread        │
│                             │     │                             │
│  ┌─────────────────────┐    │     │                             │
│  │                     │    │     │                             │
│  │  React Component    │    │     │                             │
│  │  <MedicationCard/>  │    │     │                             │
│  │                     │    │     │                             │
│  └──────────┬──────────┘    │     │                             │
│             │               │     │                             │
│             ▼               │     │                             │
│  ┌─────────────────────┐    │     │                             │
│  │                     │    │     │                             │
│  │    Virtual DOM      │    │     │                             │
│  │    Reconciliation   │    │     │                             │
│  │                     │    │     │                             │
│  └──────────┬──────────┘    │     │                             │
│             │               │     │                             │
│             ▼               │     │                             │
│  ┌─────────────────────┐    │     │                             │
│  │                     │    │     │                             │
│  │    Shadow Tree      │    │     │                             │
│  │    (C++ Yoga)       │    │     │                             │
│  │                     │    │     │                             │
│  └──────────┬──────────┘    │     │                             │
│             │               │     │                             │
│             ▼               │     │                             │
│  ┌─────────────────────┐    │     │  ┌─────────────────────┐    │
│  │                     │    │     │  │                     │    │
│  │  Native Commands    ├────┼─────┼─▶│  UIView (iOS)       │    │
│  │                     │    │     │  │  or                 │    │
│  └─────────────────────┘    │     │  │  Android.View       │    │
│                             │     │  │                     │    │
└─────────────────────────────┘     │  └─────────────────────┘    │
                                    │                             │
                                    └─────────────────────────────┘
        </pre>
      </div>
      
      <div class="platform-android">
        <strong>For Android Developers:</strong> This is similar to how RecyclerView works with its Adapter and ViewHolder pattern, but with an additional layer of abstraction.
      </div>
      <div class="platform-ios">
        <strong>For iOS Developers:</strong> This process is comparable to how UICollectionView manages its cells, but with React determining the updates instead of delegate methods.
      </div>
      <div class="callout info">
        <div class="callout-title">Performance Implications</div>
        <p>This multi-step process is why React Native apps can sometimes feel less responsive than fully native apps, especially for complex animations or interactions that require frequent updates across the bridge.</p>
      </div>
    </section>
    
    <!-- Native Modules Slide -->
    <section class="slide content-slide">
      <h2>Native Modules</h2>
      <p>Native modules allow you to write native code and expose it to JavaScript. They're useful for:</p>
      <ul>
        <li>Accessing platform APIs not yet supported by React Native</li>
        <li>Performance-critical operations</li>
        <li>Integrating with third-party native SDKs</li>
      </ul>
      <div class="columns">
        <div class="column">
          <h4>iOS Example (Objective-C)</h4>
          <pre><code>
@implementation RCTMedicationScanner

RCT_EXPORT_MODULE();

RCT_EXPORT_METHOD(scanMedication:(NSString *)barcode
                resolver:(RCTPromiseResolveBlock)resolve
                rejecter:(RCTPromiseRejectBlock)reject)
{
  // Native implementation
  resolve(@{@"name": @"Amoxicillin", @"dosage": @"500mg"});
}

@end
          </code></pre>
        </div>
        <div class="column">
          <h4>JavaScript Usage</h4>
          <pre><code>
import { NativeModules } from 'react-native';
const { MedicationScanner } = NativeModules;

async function scanMed() {
  try {
    const result = await MedicationScanner.scanMedication('123456789');
    console.log(result); // { name: 'Amoxicillin', dosage: '500mg' }
  } catch (error) {
    console.error(error);
  }
}
          </code></pre>
        </div>
      </div>
    </section>
    
    <!-- Native Components Slide -->
    <section class="slide content-slide">
      <h2>Native Components</h2>
      <p>Native components allow you to create custom UI components with native code:</p>
      <div class="columns">
        <div class="column">
          <h4>iOS Example (Swift with Objective-C bridging)</h4>
          <pre><code>
class MedicationBarcodeScannerManager: RCTViewManager {
  override func view() -> UIView! {
    return MedicationBarcodeScanner()
  }
  
  override static func requiresMainQueueSetup() -> Bool {
    return true
  }
}
          </code></pre>
        </div>
        <div class="column">
          <h4>JavaScript Usage</h4>
          <pre><code>
import { requireNativeComponent } from 'react-native';
const MedicationBarcodeScanner = requireNativeComponent('MedicationBarcodeScanner');

function ScanScreen() {
  return (
    <View style={styles.container}>
      <MedicationBarcodeScanner style={styles.scanner} />
      <Button title="Cancel" onPress={handleCancel} />
    </View>
  );
}
          </code></pre>
        </div>
      </div>
      <div class="callout deep-dive">
        <div class="callout-title">How It Works</div>
        <p>When you use a native component, React Native creates a corresponding native view in the platform's UI system. Props you pass from JavaScript are sent across the bridge and applied to the native view. Events triggered in the native view can be sent back to JavaScript through the bridge.</p>
      </div>
    </section>
    
    <!-- Threading Model Slide -->
    <section class="slide content-slide">
      <h2>Threading Model</h2>
      <p>React Native uses several threads to maintain responsiveness:</p>
      <ol>
        <li><strong>Main Thread (Native)</strong>: Handles UI updates and user interactions</li>
        <li><strong>JavaScript Thread</strong>: Runs your React code and business logic</li>
        <li><strong>Shadow Thread</strong>: Performs layout calculations</li>
        <li><strong>Background Threads</strong>: Handle various tasks like image processing</li>
      </ol>
      <div class="callout deep-dive">
        <div class="callout-title">JavaScript Thread Limitations</div>
        <p>The JavaScript thread is single-threaded, just like in a browser. This means long-running JavaScript operations can block other JavaScript code from executing. However, because UI rendering happens on a separate native thread, the app can still respond to user interactions even if the JavaScript thread is busy.</p>
      </div>
      <div class="callout tip">
        <div class="callout-title">Performance Tip</div>
        <p>Keep heavy computations off the JavaScript thread by using native modules or web workers when possible.</p>
      </div>
    </section>
    
    <!-- The New Architecture Slide -->
    <section class="slide content-slide">
      <h2>The New Architecture</h2>
      <p>React Native is evolving with a new architecture that addresses some limitations of the current design:</p>
      <h3>Key Components of the New Architecture</h3>
      <ul>
        <li><strong>JavaScript Interface (JSI)</strong>: Direct communication between JavaScript and C++ without serialization</li>
        <li><strong>Fabric</strong>: A new rendering system with synchronous operations</li>
        <li><strong>TurboModules</strong>: More efficient native modules</li>
        <li><strong>CodeGen</strong>: Automatic generation of native code from JavaScript specifications</li>
      </ul>
      <div class="callout deep-dive">
        <div class="callout-title">JSI vs Bridge</div>
        <p>The new architecture replaces the bridge with JSI (JavaScript Interface), which allows JavaScript to hold references to C++ objects and call methods on them directly. This eliminates the serialization/deserialization overhead of the bridge and enables synchronous communication between JavaScript and native code.</p>
      </div>
    </section>
    
    <!-- New Architecture Benefits Slide -->
    <section class="slide content-slide">
      <h2>New Architecture Benefits</h2>
      <div class="columns">
        <div class="column">
          <h3>Performance Improvements</h3>
          <ul>
            <li>Reduced overhead for native calls</li>
            <li>Synchronous communication</li>
            <li>More efficient memory usage</li>
            <li>Better support for animations</li>
          </ul>
        </div>
        <div class="column">
          <h3>Developer Experience</h3>
          <ul>
            <li>Type-safe interfaces</li>
            <li>Better error messages</li>
            <li>Simplified native module creation</li>
            <li>Improved debugging</li>
          </ul>
        </div>
      </div>
      <div class="callout info">
        <div class="callout-title">Migration Status</div>
        <p>The new architecture is being rolled out incrementally. Apps can adopt parts of it while maintaining compatibility with existing code. Check the React Native documentation for the latest migration guides.</p>
      </div>
    </section>
    
    <!-- Pharmacy App Example Slide -->
    <section class="slide content-slide">
      <h2>Example: Medication Reminder App</h2>
      <p>Let's trace how a medication reminder notification would flow through the React Native architecture:</p>
      <div style="text-align: center; margin: 20px 0;">
        <pre style="text-align: left; display: inline-block; font-size: 0.9rem; background-color: #f5f5f5; padding: 15px; border-radius: 5px;">
┌─────────────────────┐                                      ┌─────────────────────┐
│                     │                                      │                     │
│   JavaScript Side   │                                      │     Native Side     │
│                     │                                      │                     │
│  ┌───────────────┐  │         ┌───────────────┐           │ ┌─────────────────┐ │
│  │ Schedule      │  │         │               │           │ │ Platform         │ │
│  │ Reminder      ├──┼────────▶│    Bridge     ├───────────┼▶│ Notification     │ │
│  │ (10:00 AM     │  │         │  Serializes   │           │ │ System           │ │
│  │  Lisinopril)  │  │         │    Data       │           │ │                  │ │
│  └───────────────┘  │         └───────┬───────┘           │ └────────┬────────┘ │
│                     │                 │                    │          │          │
│                     │                 │                    │          │          │
│                     │                 │                    │          │          │
│                     │                 │                    │          ▼          │
│  ┌───────────────┐  │         ┌───────┴───────┐           │ ┌─────────────────┐ │
│  │ Update UI     │  │         │               │           │ │ User taps        │ │
│  │ Mark as taken │◀─┼─────────│    Bridge     │◀──────────┼─┤ notification     │ │
│  │ or snooze     │  │         │  Deserializes │           │ │ "Take Lisinopril"│ │
│  └───────────────┘  │         └───────────────┘           │ └─────────────────┘ │
│                     │                                      │                     │
└─────────────────────┘                                      └─────────────────────┘
        </pre>
      </div>
      <div class="callout example">
        <div class="callout-title">Real-World Example: PillRemind</div>
        <p>A healthcare provider built a medication adherence app for patients with chronic conditions. Their implementation:</p>
        <ul>
          <li><strong>JavaScript Layer</strong>: Handles medication schedules, user preferences, and UI</li>
          <li><strong>Native Module</strong>: Custom notification module that supports different notification styles on iOS and Android</li>
          <li><strong>Performance Optimization</strong>: Moved complex adherence calculations to native code to reduce bridge traffic</li>
          <li><strong>Results</strong>: 23% improvement in medication adherence among users, with 98% of notifications delivered reliably</li>
        </ul>
      </div>
    </section>
    
    <!-- Exercise Slide -->
    <section class="slide content-slide">
      <h2>Exercise: React Native Architecture Diagram</h2>
      <p>Create a diagram that illustrates the flow of data and control in a React Native application:</p>
      <ol>
        <li>Start with a user interaction (e.g., tapping a "Refill Prescription" button)</li>
        <li>Show how the event travels through the React Native architecture</li>
        <li>Illustrate how data flows back to update the UI</li>
        <li>Identify potential performance bottlenecks in this flow</li>
      </ol>
      <div class="callout info">
        <div class="callout-title">Exercise Resources</div>
        <p>Use the <a href="https://codepen.io/your-username/pen/architecture-diagram" target="_blank">Architecture Diagram CodePen</a> as a starting point.</p>
      </div>
      <div class="presenter-notes">
        This exercise helps participants visualize the complex interactions between JavaScript and native code in a React Native application, reinforcing their understanding of the architecture.
      </div>
    </section>
    
    <!-- Summary Slide -->
    <section class="slide summary-slide">
      <h2>Summary</h2>
      <ul>
        <li>React Native's architecture consists of JavaScript Thread, Native Threads, and the Bridge</li>
        <li>The Bridge enables communication between JavaScript and native code</li>
        <li>React Native renders to native UI components, not WebViews</li>
        <li>The Shadow Tree calculates layouts using Yoga, a cross-platform layout engine</li>
        <li>The new architecture (Fabric, TurboModules, and JSI) aims to improve performance and capabilities</li>
        <li>Understanding the internals helps with debugging and optimizing React Native applications</li>
      </ul>
      <div class="callout info">
        <div class="callout-title">From Theory to Practice</div>
        <p>Now that we understand how React Native works internally, we need to know where to find answers when we encounter challenges building our pharmacy app. In the next section, we'll explore the React Native documentation and community resources that will be essential as we implement features like medication reminders, barcode scanning, and offline storage.</p>
      </div>
      <div class="next-steps">
        <a href="../section-4-react-native-documentation/index.html"><strong>Next:</strong> Section 4: React Native Documentation</a>
      </div>
    </section>
  </div>
  
  <script src="../../shared/script.js"></script>
</body>
</html> 