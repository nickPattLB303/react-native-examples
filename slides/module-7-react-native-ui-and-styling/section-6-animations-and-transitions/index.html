<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Section 6: Animations and Transitions | Module 7 | React Native Training Course</title>
  <link rel="stylesheet" href="../../shared/styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
  <div class="slides">
    <!-- Title Slide -->
    <section class="slide title-slide">
      <h1>Section 6</h1>
      <h2>Animations and Transitions</h2>
      <p class="metadata">Module 7: React Native UI and Styling | 1.5-2 hours</p>
    </section>
    
    <!-- Learning Objectives Slide -->
    <section class="slide objectives-slide">
      <h2>Learning Objectives</h2>
      <ul>
        <li>Understand the importance of animations in creating engaging user experiences</li>
        <li>Master the React Native Animated API for creating fluid animations</li>
        <li>Implement common animation patterns and transitions</li>
        <li>Apply gesture-based animations for interactive elements</li>
        <li>Optimize animations for performance across different devices</li>
        <li>Create pharmaceutical-specific animations that enhance usability</li>
      </ul>
    </section>
    
    <!-- Introduction Slide -->
    <section class="slide content-slide">
      <h2>Introduction to Animations</h2>
      <p>Animations and transitions add polish, convey meaning, and improve user experience in mobile applications.</p>
      
      <div class="columns">
        <div class="column">
          <h3>Why Animations Matter</h3>
          <ul>
            <li>Provide visual feedback for user actions</li>
            <li>Help users understand state changes</li>
            <li>Guide attention to important elements</li>
            <li>Create a sense of natural motion</li>
            <li>Reduce perceived waiting time</li>
            <li>Make apps feel more polished and professional</li>
          </ul>
        </div>
        <div class="column">
          <h3>Animation Types in React Native</h3>
          <ul>
            <li><strong>Animated API</strong>: Core animation system</li>
            <li><strong>LayoutAnimation</strong>: Simple animations for layout changes</li>
            <li><strong>Gesture-based animations</strong>: Interactive feedback</li>
            <li><strong>Lottie</strong>: Complex vector animations</li>
            <li><strong>Reanimated</strong>: Performance-focused animations</li>
          </ul>
        </div>
      </div>
      
      <div class="callout info">
        <div class="callout-title">Pharmaceutical Application Focus</div>
        <p>In healthcare apps, subtle animations help illustrate medication timing, dosage changes, and adherence patterns without causing distraction or confusion.</p>
      </div>
    </section>
    
    <!-- Animated API Fundamentals Slide -->
    <section class="slide content-slide">
      <h2>Animated API Fundamentals</h2>
      
      <div class="columns">
        <div class="column">
          <h3>Core Concepts</h3>
          <ul>
            <li><strong>Animated.Value</strong>: Stores animation state</li>
            <li><strong>Animated Components</strong>: Special components that can be animated (View, Text, Image, etc.)</li>
            <li><strong>Animation Types</strong>: Timing, spring, decay</li>
            <li><strong>Composition</strong>: Parallel, sequence, stagger</li>
            <li><strong>Interpolation</strong>: Map input ranges to output ranges</li>
          </ul>
          
          <h3>Basic Workflow</h3>
          <ol>
            <li>Create Animated.Value for properties to animate</li>
            <li>Configure animation with timing, spring, etc.</li>
            <li>Connect Animated.Value to component style props</li>
            <li>Start animation with .start() method</li>
            <li>Optionally set up animation completion callbacks</li>
          </ol>
        </div>
        <div class="column">
          <pre><code class="jsx">import React, { useRef, useEffect } from 'react';
import { Animated, View, StyleSheet } from 'react-native';

const FadeInView = ({ children }) => {
  const opacity = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    Animated.timing(opacity, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true,
    }).start();
  }, []);
  
  return (
    <Animated.View style={{
      ...styles.container,
      opacity: opacity,
    }}>
      {children}
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    backgroundColor: 'white',
    borderRadius: 8,
  },
});

// Example usage
const MedicationReminder = () => (
  <FadeInView>
    <Text style={styles.title}>Time to take Lisinopril</Text>
    <Text style={styles.subtitle}>10mg - Once daily</Text>
  </FadeInView>
);</code></pre>
        </div>
      </div>
      
      <div class="callout tip">
        <div class="callout-title">Performance Tip</div>
        <p>Always use <code>useNativeDriver: true</code> when possible, which offloads animations to the native thread for better performance.</p>
      </div>
    </section>
    
    <!-- Animation Types Slide -->
    <section class="slide content-slide">
      <h2>Animation Types</h2>
      
      <div class="columns">
        <div class="column">
          <h3>Animated.timing()</h3>
          <p>Animates a value over time using easing functions.</p>
          <pre><code class="jsx">Animated.timing(animatedValue, {
  toValue: 1,
  duration: 300,
  easing: Easing.ease, // Linear, ease, bounce, etc.
  useNativeDriver: true,
}).start();</code></pre>
          
          <h3>Animated.spring()</h3>
          <p>Creates spring-based animations for more natural motion.</p>
          <pre><code class="jsx">Animated.spring(animatedValue, {
  toValue: 1,
  friction: 7,    // Controls "bounciness"
  tension: 40,    // Controls speed
  useNativeDriver: true,
}).start();</code></pre>
          
          <h3>Animated.decay()</h3>
          <p>Starts with initial velocity and gradually slows to a stop.</p>
          <pre><code class="jsx">Animated.decay(animatedValue, {
  velocity: 0.5,  // Initial velocity
  deceleration: 0.997, // Rate of decay
  useNativeDriver: true,
}).start();</code></pre>
        </div>
        <div class="column">
          <h3>Composition Functions</h3>
          
          <h4>Animated.parallel()</h4>
          <p>Run multiple animations at the same time.</p>
          <pre><code class="jsx">Animated.parallel([
  Animated.timing(opacity, { 
    toValue: 1, duration: 500, useNativeDriver: true 
  }),
  Animated.spring(scale, { 
    toValue: 1, tension: 20, useNativeDriver: true 
  }),
]).start();</code></pre>
          
          <h4>Animated.sequence()</h4>
          <p>Run animations one after another.</p>
          <pre><code class="jsx">Animated.sequence([
  Animated.timing(translateX, { 
    toValue: 50, duration: 300, useNativeDriver: true 
  }),
  Animated.timing(translateY, { 
    toValue: 50, duration: 300, useNativeDriver: true 
  }),
]).start();</code></pre>
          
          <h4>Animated.stagger()</h4>
          <p>Start animations with staggered delays.</p>
          <pre><code class="jsx">Animated.stagger(100, [
  Animated.timing(item1Opacity, {...}),
  Animated.timing(item2Opacity, {...}),
  Animated.timing(item3Opacity, {...}),
]).start();</code></pre>
        </div>
      </div>
    </section>
    
    <!-- Value Interpolation Slide -->
    <section class="slide content-slide">
      <h2>Value Interpolation</h2>
      
      <div class="columns">
        <div class="column">
          <h3>What is Interpolation?</h3>
          <p>Interpolation maps input values to output values, allowing you to:</p>
          <ul>
            <li>Convert ranges (e.g., 0-1 to 0-100%)</li>
            <li>Create non-linear animations</li>
            <li>Generate color transitions</li>
            <li>Create rotation effects</li>
            <li>Apply easing or clamping to values</li>
          </ul>
          
          <h3>Common Interpolation Use Cases</h3>
          <ul>
            <li>Translating a value to a position</li>
            <li>Scaling based on scroll position</li>
            <li>Fading between colors</li>
            <li>Rotating elements</li>
            <li>Combining multiple transformations</li>
          </ul>
        </div>
        <div class="column">
          <h3>Basic Interpolation</h3>
          <pre><code class="jsx">const translateX = scrollY.interpolate({
  inputRange: [0, 300],
  outputRange: [0, -50],
});</code></pre>
          
          <h3>Color Interpolation</h3>
          <pre><code class="jsx">const backgroundColor = progress.interpolate({
  inputRange: [0, 0.5, 1],
  outputRange: ['#F44336', '#FFEB3B', '#4CAF50'],
});</code></pre>
          
          <h3>Rotation Interpolation</h3>
          <pre><code class="jsx">const rotate = animation.interpolate({
  inputRange: [0, 1],
  outputRange: ['0deg', '360deg'],
});</code></pre>
          
          <h3>Example: Medication Progress Ring</h3>
          <pre><code class="jsx">const strokeDashoffset = progress.interpolate({
  inputRange: [0, 100],
  outputRange: [circumference, 0],
  extrapolate: 'clamp',
});

// In the component:
<Animated.View style={{
  transform: [{ rotate: rotateInterpolation }],
}}>
  <Svg width={100} height={100}>
    <AnimatedCircle
      cx={50}
      cy={50}
      r={45}
      stroke="#4CAF50"
      strokeWidth={5}
      strokeDasharray={circumference}
      strokeDashoffset={strokeDashoffset}
      fill="transparent"
    />
  </Svg>
</Animated.View></code></pre>
        </div>
      </div>
    </section>
    
    <!-- Layout Animation Slide -->
    <section class="slide content-slide">
      <h2>LayoutAnimation</h2>
      
      <div class="columns">
        <div class="column">
          <h3>What is LayoutAnimation?</h3>
          <p>A simpler way to animate layout changes with minimal code:</p>
          <ul>
            <li>Automatically animates views to their new position</li>
            <li>Triggers on next render cycle after state change</li>
            <li>Works on entire component tree layout changes</li>
            <li>Less code than Animated API for simple transitions</li>
            <li>Not as customizable but very convenient</li>
          </ul>
          
          <h3>When to Use LayoutAnimation</h3>
          <ul>
            <li>Expanding/collapsing sections</li>
            <li>Adding/removing list items</li>
            <li>Changing dimensions or positioning</li>
            <li>Toggling UI elements</li>
            <li>Simple appear/disappear transitions</li>
          </ul>
          
          <div class="callout warning">
            <div class="callout-title">Android Note</div>
            <p>On Android, you need to add <code>UIManager.setLayoutAnimationEnabledExperimental(true);</code> to enable LayoutAnimation</p>
          </div>
        </div>
        <div class="column">
          <h3>Basic Usage</h3>
          <pre><code class="jsx">import React, { useState } from 'react';
import { 
  View, 
  Text, 
  TouchableOpacity, 
  LayoutAnimation, 
  Platform, 
  UIManager, 
  StyleSheet 
} from 'react-native';

// Enable for Android
if (Platform.OS === 'android') {
  UIManager.setLayoutAnimationEnabledExperimental(true);
}

const ExpandableCard = ({ title, content }) => {
  const [expanded, setExpanded] = useState(false);
  
  const toggleExpand = () => {
    // Configure animation before state change
    LayoutAnimation.configureNext(
      LayoutAnimation.Presets.easeInEaseOut
    );
    setExpanded(!expanded);
  };
  
  return (
    <View style={styles.card}>
      <TouchableOpacity onPress={toggleExpand}>
        <Text style={styles.title}>{title}</Text>
      </TouchableOpacity>
      
      {expanded && (
        <View style={styles.content}>
          <Text>{content}</Text>
        </View>
      )}
    </View>
  );
};</code></pre>
          
          <h3>Preset Configurations</h3>
          <pre><code class="jsx">// Common presets
LayoutAnimation.Presets.easeInEaseOut
LayoutAnimation.Presets.linear
LayoutAnimation.Presets.spring

// Custom configuration
LayoutAnimation.configureNext({
  duration: 300,
  create: {
    type: LayoutAnimation.Types.spring,
    property: LayoutAnimation.Properties.opacity,
    springDamping: 0.7,
  },
  update: {
    type: LayoutAnimation.Types.spring,
    springDamping: 0.7,
  },
});</code></pre>
        </div>
      </div>
    </section>
    
    <!-- Gesture-Based Animations Slide -->
    <section class="slide content-slide">
      <h2>Gesture-Based Animations</h2>
      
      <div class="columns">
        <div class="column">
          <h3>Key Concepts</h3>
          <ul>
            <li>Combining gestures with animations for interactive UIs</li>
            <li>Using PanResponder to track touch movements</li>
            <li>Connecting gesture values to animated values</li>
            <li>Creating physics-based interactions</li>
            <li>Handling completion of gesture animations</li>
          </ul>
          
          <h3>Common Gesture Animations</h3>
          <ul>
            <li>Swipe-to-dismiss cards</li>
            <li>Drag and drop interfaces</li>
            <li>Pull-to-refresh</li>
            <li>Pinch-to-zoom</li>
            <li>Swipeable list actions</li>
            <li>Interactive carousels</li>
          </ul>
          
          <h3>Pharmaceutical Applications</h3>
          <ul>
            <li>Swipeable medication cards</li>
            <li>Interactive dosage adjusters</li>
            <li>Timeline scrubbing for medication history</li>
            <li>Drag-to-record symptom severity</li>
          </ul>
        </div>
        <div class="column">
          <h3>Basic PanResponder Example</h3>
          <pre><code class="jsx">import React, { useRef } from 'react';
import { Animated, PanResponder, View } from 'react-native';

const DraggableMedicationCard = () => {
  const pan = useRef(new Animated.ValueXY()).current;
  
  const panResponder = useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onPanResponderMove: Animated.event(
        [
          null,
          { dx: pan.x, dy: pan.y }
        ],
        { useNativeDriver: false }
      ),
      onPanResponderRelease: () => {
        Animated.spring(pan, {
          toValue: { x: 0, y: 0 },
          friction: 5,
          useNativeDriver: true,
        }).start();
      }
    })
  ).current;
  
  return (
    <Animated.View
      style={{
        transform: [{ translateX: pan.x }, { translateY: pan.y }]
      }}
      {...panResponder.panHandlers}
    >
      {/* Medication Card Content */}
    </Animated.View>
  );
};</code></pre>
          
          <h3>Swipeable List Items</h3>
          <pre><code class="jsx">const SwipeableItem = () => {
  const swipeAnim = useRef(new Animated.Value(0)).current;
  
  // PanResponder configuration...
  
  // Use interpolation to create different effects
  const opacity = swipeAnim.interpolate({
    inputRange: [-150, 0, 150],
    outputRange: [0.5, 1, 0.5],
  });
  
  const actionOpacity = swipeAnim.interpolate({
    inputRange: [-150, -120, -50],
    outputRange: [1, 0.5, 0],
    extrapolate: 'clamp',
  });
  
  return (
    <View style={styles.container}>
      {/* Action buttons revealed when swiped */}
      {/* Main card content that moves with swipe */}
    </View>
  );
};</code></pre>
        </div>
      </div>
    </section>
    
    <!-- Advanced Animations Slide -->
    <section class="slide content-slide">
      <h2>Advanced Animation Techniques</h2>
      
      <div class="columns">
        <div class="column">
          <h3>Shared Element Transitions</h3>
          <p>Animate elements smoothly between screens for continuity:</p>
          <ul>
            <li>Creates connection between navigation states</li>
            <li>Helps users understand content relationships</li>
            <li>Used for details screens, photo galleries, etc.</li>
          </ul>
          <pre><code class="jsx">// Using libraries like:
// - react-navigation-shared-element
// - react-native-shared-element</code></pre>
          
          <h3>Animated Lists</h3>
          <ul>
            <li>Staggered animations for list items</li>
            <li>Animated additions and removals</li>
            <li>Reordering animations</li>
          </ul>
          <pre><code class="jsx">// Staggered entry animation
{items.map((item, index) => {
  const animation = new Animated.Value(0);
  
  useEffect(() => {
    Animated.timing(animation, {
      toValue: 1,
      duration: 300,
      delay: index * 100,
      useNativeDriver: true,
    }).start();
  }, []);
  
  return (
    <Animated.View
      style={{
        opacity: animation,
        transform: [{
          translateY: animation.interpolate({
            inputRange: [0, 1],
            outputRange: [50, 0],
          }),
        }],
      }}
    >
      {/* Item content */}
    </Animated.View>
  );
})}</code></pre>
        </div>
        <div class="column">
          <h3>Lottie Animations</h3>
          <p>Using Adobe After Effects animations in React Native:</p>
          <ul>
            <li>Complex vector animations</li>
            <li>Small file size compared to video</li>
            <li>Programmatic control over playback</li>
            <li>Perfect for loading indicators, success states, etc.</li>
          </ul>
          <pre><code class="jsx">import LottieView from 'lottie-react-native';

const MedicationTakenAnimation = () => {
  const animationRef = useRef(null);
  
  useEffect(() => {
    if (animationRef.current) {
      // Auto-play the animation
      animationRef.current.play();
    }
  }, []);
  
  return (
    <LottieView
      ref={animationRef}
      source={require('../animations/success.json')}
      style={{ width: 200, height: 200 }}
      loop={false}
      autoPlay={false}
    />
  );
};</code></pre>
          
          <h3>Reanimated 2</h3>
          <p>A more powerful animation library for React Native:</p>
          <ul>
            <li>Runs animations on the UI thread</li>
            <li>Better performance for complex animations</li>
            <li>Worklet system for offloading JS</li>
            <li>Advanced gesture handling</li>
          </ul>
          <pre><code class="jsx">import Animated, { 
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming
} from 'react-native-reanimated';</code></pre>
        </div>
      </div>
    </section>
    
    <!-- Animation Examples for Pharmaceutical Apps Slide -->
    <section class="slide content-slide">
      <h2>Animation Examples for Pharmaceutical Apps</h2>
      
      <div class="columns">
        <div class="column">
          <h3>1. Medication Reminder Animation</h3>
          <pre><code class="jsx">const MedicationReminder = () => {
  const scale = useRef(new Animated.Value(0.8)).current;
  const opacity = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    Animated.parallel([
      Animated.spring(scale, {
        toValue: 1,
        friction: 6,
        useNativeDriver: true,
      }),
      Animated.timing(opacity, {
        toValue: 1,
        duration: 400,
        useNativeDriver: true,
      }),
    ]).start();
  }, []);
  
  return (
    <Animated.View style={{
      opacity,
      transform: [{ scale }],
      backgroundColor: '#E3F2FD',
      borderRadius: 12,
      padding: 20,
    }}>
      <Text style={styles.time}>8:00 AM</Text>
      <Text style={styles.title}>Time for Lisinopril</Text>
      <Text style={styles.dosage}>10mg - Take with water</Text>
      <View style={styles.buttonContainer}>
        <TouchableOpacity style={styles.takeButton}>
          <Text style={styles.buttonText}>TAKE NOW</Text>
        </TouchableOpacity>
        <TouchableOpacity style={styles.skipButton}>
          <Text style={styles.buttonText}>SKIP</Text>
        </TouchableOpacity>
      </View>
    </Animated.View>
  );
};</code></pre>
        </div>
        <div class="column">
          <h3>2. Dosage Progress Animation</h3>
          <pre><code class="jsx">const DosageProgress = ({ progress }) => {
  const animatedProgress = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    Animated.timing(animatedProgress, {
      toValue: progress,
      duration: 1000,
      useNativeDriver: false,
    }).start();
  }, [progress]);
  
  const width = animatedProgress.interpolate({
    inputRange: [0, 100],
    outputRange: ['0%', '100%'],
  });
  
  const backgroundColor = animatedProgress.interpolate({
    inputRange: [0, 50, 100],
    outputRange: ['#F44336', '#FFEB3B', '#4CAF50'],
  });
  
  return (
    <View style={styles.progressContainer}>
      <Animated.View 
        style={[
          styles.progressBar, 
          { width, backgroundColor }
        ]} 
      />
      <Animated.Text style={styles.progressText}>
        {Math.round(animatedProgress.__getValue())}% Complete
      </Animated.Text>
    </View>
  );
};</code></pre>
          
          <h3>3. Side Effects Severity Slider</h3>
          <pre><code class="jsx">const SeveritySlider = ({ onChange }) => {
  const pan = useRef(new Animated.Value(0)).current;
  
  // PanResponder setup...
  
  const backgroundColor = pan.interpolate({
    inputRange: [0, 100, 200],
    outputRange: ['#4CAF50', '#FFEB3B', '#F44336'],
  });
  
  const severity = pan.interpolate({
    inputRange: [0, 100, 200],
    outputRange: ['Mild', 'Moderate', 'Severe'],
  });
  
  return (
    <View style={styles.sliderContainer}>
      <Text style={styles.label}>Rate symptom severity:</Text>
      <View style={styles.track}>
        <Animated.View 
          style={[styles.thumb, { backgroundColor }]}
          {...panResponder.panHandlers}
        />
      </View>
      <Animated.Text style={styles.severityText}>
        {severity}
      </Animated.Text>
    </View>
  );
};</code></pre>
        </div>
      </div>
    </section>
    
    <!-- Performance Optimization Slide -->
    <section class="slide content-slide">
      <h2>Performance Optimization</h2>
      
      <div class="columns">
        <div class="column">
          <h3>Common Performance Issues</h3>
          <ul>
            <li>Janky animations (dropping frames)</li>
            <li>High CPU/memory usage during animations</li>
            <li>Animation lag on gesture tracking</li>
            <li>Slow startup when many animations initialize</li>
            <li>UI thread blocking</li>
          </ul>
          
          <h3>Optimization Strategies</h3>
          <ol>
            <li><strong>Use Native Driver</strong>: Offload animation work to native thread</li>
            <li><strong>Optimize Renders</strong>: Prevent unnecessary re-renders during animation</li>
            <li><strong>Hardware Acceleration</strong>: Enable for complex animations</li>
            <li><strong>Simplify Animations</strong>: Fewer animated properties = better performance</li>
            <li><strong>Debounce Gestures</strong>: Prevent too many updates from rapid gestures</li>
            <li><strong>Avoid Layout Thrashing</strong>: Don't constantly measure and update layout</li>
          </ol>
        </div>
        <div class="column">
          <h3>Using the Native Driver</h3>
          <pre><code class="jsx">// Always use when possible
Animated.timing(opacity, {
  toValue: 1,
  duration: 300,
  useNativeDriver: true,
}).start();</code></pre>
          
          <div class="callout warning">
            <div class="callout-title">Native Driver Limitations</div>
            <p>Native driver only works with non-layout properties:</p>
            <ul>
              <li>Works with: opacity, transform</li>
              <li>Doesn't work with: width, height, position, flex, etc.</li>
            </ul>
          </div>
          
          <h3>Measuring Performance</h3>
          <pre><code class="jsx">// Debug performance in development
import { LogBox } from 'react-native';
LogBox.ignoreLogs(['Animated: `useNativeDriver`']);

// Use Flipper plugins for animation debugging
// Use React Native Performance Monitor</code></pre>
          
          <h3>Reanimated for Better Performance</h3>
          <pre><code class="jsx">// Running animations on UI thread
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
} from 'react-native-reanimated';

const AnimatedComponent = () => {
  const opacity = useSharedValue(0);
  
  const animatedStyle = useAnimatedStyle(() => {
    return {
      opacity: opacity.value,
    };
  });
  
  // Start animation
  const startAnimation = () => {
    opacity.value = withTiming(1, { duration: 500 });
  };
  
  return (
    <Animated.View style={animatedStyle}>
      {/* Content */}
    </Animated.View>
  );
};</code></pre>
        </div>
      </div>
    </section>
    
    <!-- Best Practices Slide -->
    <section class="slide content-slide">
      <h2>Animation Best Practices</h2>
      
      <div class="columns">
        <div class="column">
          <h3>General Guidelines</h3>
          <ul>
            <li><strong>Purpose First</strong>: Use animations that serve a purpose, not just for decoration</li>
            <li><strong>Subtlety</strong>: Subtle animations are often more effective than dramatic ones</li>
            <li><strong>Consistent Motion</strong>: Maintain consistent timing and motion patterns</li>
            <li><strong>Performance</strong>: Always optimize for performance, especially on lower-end devices</li>
            <li><strong>Accessibility</strong>: Consider users who prefer reduced motion</li>
            <li><strong>Testing</strong>: Test animations on actual devices, not just simulators</li>
          </ul>
          
          <h3>Animation Choreography</h3>
          <ul>
            <li><strong>Hierarchy</strong>: Use animation to establish visual hierarchy</li>
            <li><strong>Timing</strong>: Important elements animate first</li>
            <li><strong>Direction</strong>: Maintain consistent direction for similar actions</li>
            <li><strong>Continuity</strong>: Create smooth visual continuity between states</li>
            <li><strong>Feedback</strong>: Use animation to provide instant feedback</li>
          </ul>
        </div>
        <div class="column">
          <h3>For Pharmaceutical Applications</h3>
          <ul>
            <li><strong>Clarity</strong>: Animations should clarify information, not obscure it</li>
            <li><strong>Appropriate Timing</strong>: Allow sufficient time for important information to be read</li>
            <li><strong>Visual Cues</strong>: Use animations to draw attention to critical information</li>
            <li><strong>Error Prevention</strong>: Animate validation errors in forms clearly</li>
            <li><strong>Progress Indication</strong>: Use animations to show treatment progress</li>
            <li><strong>Reminder Notifications</strong>: Use subtle but noticeable animations for medication reminders</li>
          </ul>
          
          <h3>Responding to System Settings</h3>
          <pre><code class="jsx">import { AccessibilityInfo, Platform } from 'react-native';

const AnimatedComponent = () => {
  const [reducedMotion, setReducedMotion] = useState(false);
  
  useEffect(() => {
    // Check if reduced motion is enabled
    const reducedMotionListener = 
      AccessibilityInfo.addEventListener(
        'reduceMotionChanged',
        setReducedMotion
      );
      
    AccessibilityInfo.isReduceMotionEnabled()
      .then(setReducedMotion);
      
    return () => {
      reducedMotionListener.remove();
    };
  }, []);
  
  // Use shorter/simpler animations when reducedMotion is true
};</code></pre>
        </div>
      </div>
      
      <div class="callout info">
        <div class="callout-title">Healthcare Focus</div>
        <p>In medical apps, prioritize clarity and readability over animation complexity. Use animations to enhance understanding of health information, not distract from it.</p>
      </div>
    </section>
    
    <!-- Summary Slide -->
    <section class="slide summary-slide">
      <h2>Summary</h2>
      <ul>
        <li>Animations and transitions improve user experience by providing visual feedback and guiding attention</li>
        <li>The React Native Animated API provides powerful tools for creating fluid animations</li>
        <li>LayoutAnimation offers a simpler way to animate layout changes with minimal code</li>
        <li>Gesture-based animations create interactive and responsive user interfaces</li>
        <li>Value interpolation allows mapping animation values to different output ranges</li>
        <li>Advanced techniques like shared element transitions create polished experiences</li>
        <li>For pharmaceutical applications, animations should prioritize clarity and enhance understanding</li>
        <li>Performance optimization is critical for smooth animations across all devices</li>
      </ul>
      <div class="next-steps">
        <p>Next: Module Challenge - Building a Complete Medication Detail Screen</p>
      </div>
    </section>
    
    <!-- Further Reading Slide -->
    <section class="slide content-slide">
      <h2>Further Reading</h2>
      <ul>
        <li><a href="https://reactnative.dev/docs/animated">React Native Animated API Documentation</a> - Official documentation</li>
        <li><a href="https://reactnative.dev/docs/layoutanimation">LayoutAnimation Documentation</a> - Official documentation</li>
        <li><a href="https://docs.swmansion.com/react-native-reanimated/">React Native Reanimated</a> - Advanced animation library</li>
        <li><a href="https://airbnb.io/lottie/">Lottie for React Native</a> - Complex vector animations</li>
        <li><a href="https://medium.com/react-native-training/react-native-animations-using-the-animated-api-ebe8e0669fae">React Native Animations Deep Dive</a> - Tutorial series</li>
      </ul>
      <div class="callout info">
        <div class="callout-title">Exercise Preview</div>
        <p>In the upcoming module challenge, you'll apply everything you've learned to create a complete medication detail screen with responsive design, advanced components, and fluid animations.</p>
      </div>
    </section>
  </div>
  
  <script src="../../shared/script.js"></script>
</body>
</html> 