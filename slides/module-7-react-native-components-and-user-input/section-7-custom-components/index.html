<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Section 7: Custom Input Components | React Native Training Course</title>
  <link rel="stylesheet" href="../../shared/styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
  <div class="slides">
    <!-- Title Slide -->
    <section class="slide title-slide">
      <h1>Section 7</h1>
      <h2>Custom Components</h2>
      <p class="metadata">Module 7 | 45-60 minutes</p>
    </section>

    <!-- Learning Objectives Slide -->
    <section class="slide objectives-slide">
      <h2>Learning Objectives</h2>
      <ul>
        <li>Create reusable custom components in React Native using TypeScript</li>
        <li>Apply best practices for component composition and props design with strong typing</li>
        <li>Implement custom UI components specific to your application needs</li>
        <li>Create components that handle both appearance and behavior</li>
        <li>Properly document custom components for reuse</li>
        <li>Test custom components to ensure they work as expected</li>
      </ul>
      <div class="metadata">
        <p><strong>Time:</strong> 45-60 minutes</p>
        <p><strong>Prerequisites:</strong> Core React Native Components from Section 1</p>
      </div>
    </section>

    <!-- Custom Components Overview Slide -->
    <section class="slide content-slide">
      <h2>Custom Components Overview</h2>
      <div class="columns">
        <div class="column">
          <p>Custom components allow you to encapsulate and reuse UI elements and logic throughout your application, with added benefits from TypeScript:</p>
          <ul>
            <li>More consistent user experience</li>
            <li>Reduced code duplication</li>
            <li>Simplified maintenance</li>
            <li>Better organization and readability</li>
            <li>Easier testing</li>
            <li>Type safety and better developer experience</li>
          </ul>
        </div>
        <div class="column">
          <div class="image-container">
            <img src="images/component-hierarchy.png" alt="Illustration of component hierarchy">
          </div>
        </div>
      </div>
    </section>

    <!-- Basic Component Structure Slide -->
    <section class="slide code-slide">
      <h2>Basic Custom Component Structure</h2>
      <pre><code class="language-jsx">
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

// Define the component props interface
interface CustomComponentProps {
  title: string;
  subtitle?: string;
  backgroundColor?: string;
  onPress?: () => void;
  children?: React.ReactNode;
}

const CustomComponent: React.FC<CustomComponentProps> = ({
  title,
  subtitle,
  backgroundColor = '#ffffff',
  onPress,
  children
}) => {
  return (
    <View style={[styles.container, { backgroundColor }]}>
      <Text style={styles.title}>{title}</Text>
      {subtitle && <Text style={styles.subtitle}>{subtitle}</Text>}
      <View style={styles.content}>
        {children}
      </View>
    </View>
  );
};
      </code></pre>
    </section>

    <!-- Custom Text Input Slide -->
    <section class="slide code-slide">
      <h2>Custom Text Input Component</h2>
      <pre><code class="language-jsx">
interface CustomTextInputProps extends Omit<TextInputProps, 'style'> {
  label: string;
  error?: string;
  required?: boolean;
}

const CustomTextInput: React.FC<CustomTextInputProps> = ({
  label,
  value,
  onChangeText,
  placeholder,
  error,
  keyboardType = 'default',
  secureTextEntry = false,
  maxLength,
  required = false,
  ...rest
}) => {
  const [isFocused, setIsFocused] = useState<boolean>(false);
  
  return (
    <View style={styles.container}>
      <Text style={styles.label}>
        {label}
        {required && <Text style={styles.required}> *</Text>}
      </Text>
      
      <TextInput
        style={[
          styles.input,
          isFocused && styles.focusedInput,
          error && styles.errorInput
        ]}
        value={value}
        onChangeText={onChangeText}
        onFocus={() => setIsFocused(true)}
        onBlur={() => setIsFocused(false)}
        placeholder={placeholder}
        keyboardType={keyboardType}
        secureTextEntry={secureTextEntry}
        maxLength={maxLength}
        placeholderTextColor="#999"
        {...rest}
      />
      
      {error && <Text style={styles.errorText}>{error}</Text>}
    </View>
  );
};
      </code></pre>
    </section>

    <!-- Custom Quantity Selector Slide -->
    <section class="slide code-slide">
      <h2>Custom Quantity Selector Component</h2>
      <pre><code class="language-jsx">
interface QuantitySelectorProps {
  label?: string;
  value: number;
  onChange: (value: number) => void;
  min?: number;
  max?: number;
  step?: number;
  disabled?: boolean;
}

const QuantitySelector: React.FC<QuantitySelectorProps> = ({
  label,
  value,
  onChange,
  min = 1,
  max = 100,
  step = 1,
  disabled = false,
}) => {
  const increment = () => {
    if (value < max) {
      onChange(value + step);
    }
  };
  
  const decrement = () => {
    if (value > min) {
      onChange(value - step);
    }
  };
  
  return (
    <View style={styles.container}>
      {label && <Text style={styles.label}>{label}</Text>}
      
      <View style={styles.controlsContainer}>
        <TouchableOpacity 
          style={[styles.button, value <= min && styles.disabledButton]}
          onPress={decrement}
          disabled={value <= min || disabled}
        >
          <Text style={styles.buttonText}>-</Text>
        </TouchableOpacity>
        
        <View style={styles.valueContainer}>
          <Text style={styles.value}>{value}</Text>
        </View>
        
        <TouchableOpacity 
          style={[styles.button, value >= max && styles.disabledButton]}
          onPress={increment}
          disabled={value >= max || disabled}
        >
          <Text style={styles.buttonText}>+</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
};
      </code></pre>
    </section>

    <!-- Custom UI Cards Slide -->
    <section class="slide content-slide">
      <h2>Custom Card Component</h2>
      <div class="columns">
        <div class="column">
          <pre><code class="language-jsx">
interface MedicationCardProps {
  name: string;
  dosage: string;
  description: string;
  onPress: () => void;
  isActive?: boolean;
}

const MedicationCard: React.FC<MedicationCardProps> = ({
  name,
  dosage,
  description,
  onPress,
  isActive = false,
}) => {
  return (
    <TouchableOpacity
      style={[styles.card, isActive && styles.activeCard]}
      onPress={onPress}
      activeOpacity={0.8}
    >
      <View style={styles.header}>
        <Text style={styles.name}>{name}</Text>
        <Text style={styles.dosage}>{dosage}</Text>
      </View>
      
      <Text style={styles.description} numberOfLines={2}>
        {description}
      </Text>
      
      <View style={styles.footer}>
        <Text style={styles.actionText}>Tap for details</Text>
      </View>
    </TouchableOpacity>
  );
};
          </code></pre>
        </div>
        <div class="column">
          <div class="image-container">
            <img src="images/medication-card.png" alt="Example of a medication card component">
          </div>
          <p>Custom cards can display application-specific information in a consistent, reusable format</p>
        </div>
      </div>
    </section>

    <!-- Status Badge Component Slide -->
    <section class="slide content-slide">
      <h2>Custom Status Badge Component</h2>
      <div class="columns">
        <div class="column">
          <pre><code class="language-jsx">
type StatusType = 'active' | 'pending' | 
  'completed' | 'expired' | string;

interface StatusBadgeProps {
  status: StatusType;
  customStyle?: ViewStyle;
  textStyle?: TextStyle;
}

const StatusBadge: React.FC<StatusBadgeProps> = ({ 
  status, 
  customStyle, 
  textStyle 
}) => {
  const getStatusColor = (): { bg: string; text: string } => {
    switch (status.toLowerCase()) {
      case 'active':
        return { bg: '#DEFFEE', text: '#00A36A' };
      case 'pending':
        return { bg: '#FFF5DD', text: '#D9A000' };
      case 'completed':
        return { bg: '#E5F5FF', text: '#007AFF' };
      case 'expired':
        return { bg: '#FFEBEB', text: '#FF3B30' };
      default:
        return { bg: '#F0F0F0', text: '#777777' };
    }
  };
  
  const { bg, text } = getStatusColor();
  
  return (
    <View style={[styles.badge, { backgroundColor: bg }]}>
      <Text style={[styles.text, { color: text }]}>
        {status}
      </Text>
    </View>
  );
};
          </code></pre>
        </div>
        <div class="column">
          <div class="image-container">
            <img src="images/status-badges.png" alt="Examples of status badges">
          </div>
          <p>Small, focused components make your UI consistent and easy to maintain</p>
        </div>
      </div>
    </section>

    <!-- Functional Components Slide -->
    <section class="slide content-slide">
      <h2>Custom Functional Components</h2>
      <div class="columns">
        <div class="column">
          <h3>Loading Overlay</h3>
          <pre><code class="language-jsx">
interface LoadingOverlayProps {
  isLoading: boolean;
  message?: string;
  transparent?: boolean;
  children?: React.ReactNode;
}

const LoadingOverlay: React.FC<LoadingOverlayProps> = ({
  isLoading,
  message = 'Loading...',
  transparent = true,
  children,
}) => {
  if (!isLoading) return <>{children}</>;
  
  return (
    <View style={styles.container}>
      {children && <View style={transparent ? 
        styles.contentBlurred : styles.content}>
        {children}
      </View>}
      
      <View style={[styles.overlay, 
        transparent && styles.transparentOverlay]}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#007AFF" />
          <Text style={styles.message}>{message}</Text>
        </View>
      </View>
    </View>
  );
};
          </code></pre>
        </div>
        <div class="column">
          <h3>Error Boundary</h3>
          <pre><code class="language-jsx">
interface ErrorBoundaryProps {
  children: ReactNode;
  onReset?: () => void;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends 
  Component<ErrorBoundaryProps, ErrorBoundaryState> {
  
  static getDerivedStateFromError(error: Error): 
    ErrorBoundaryState {
    // Update state so the next render will show 
    // the fallback UI
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo): 
    void {
    // You can log the error to an error reporting service
    console.log('Error caught by boundary:', 
      error, errorInfo);
  }
  
  render(): ReactNode {
    if (this.state.hasError) {
      // Render fallback UI
      return (
        <View style={styles.container}>
          <Text style={styles.header}>Something went wrong</Text>
          <Button title="Try Again" onPress={this.resetError} />
        </View>
      );
    }
    
    return this.props.children;
  }
}
          </code></pre>
        </div>
      </div>
    </section>

    <!-- Component Design Principles Slide -->
    <section class="slide content-slide">
      <h2>Component Design Principles</h2>
      <div class="columns">
        <div class="column">
          <h3>General Principles</h3>
          <ul>
            <li><strong>Single Responsibility:</strong> Each component should focus on doing one thing well</li>
            <li><strong>Composability:</strong> Components should be easily combined with other components</li>
            <li><strong>Reusability:</strong> Components should be designed to be reused across the application</li>
            <li><strong>Customizability:</strong> Components should accept props for customization</li>
            <li><strong>Self-Contained:</strong> Components should manage their own state when appropriate</li>
          </ul>
        </div>
        <div class="column">
          <h3>Props Design</h3>
          <ul>
            <li><strong>Provide Defaults:</strong> Set sensible default values for optional props</li>
            <li><strong>Use TypeScript Types:</strong> Define proper interfaces for component props</li>
            <li><strong>Consistent Naming:</strong> Use consistent naming conventions for props</li>
            <li><strong>Minimal Props Interface:</strong> Only expose what's necessary</li>
            <li><strong>Props Extension:</strong> Extend existing types when appropriate (e.g., extending TextInputProps)</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Component Documentation Slide -->
    <section class="slide code-slide">
      <h2>Component Documentation</h2>
      <pre><code class="language-jsx">
/**
 * MedicationCard - Displays medication information in a card format
 * 
 * @param props - Component props
 * @param props.name - The name of the medication
 * @param props.dosage - The dosage information
 * @param props.description - Description or instructions
 * @param props.onPress - Function to call when card is pressed
 * @param props.isActive - Whether the card is in active state
 * 
 * @example
 * <MedicationCard
 *   name="Ibuprofen"
 *   dosage="200mg"
 *   description="Take with food, twice daily"
 *   onPress={() => handlePress(medication.id)}
 * />
 */
interface MedicationCardProps {
  name: string;
  dosage: string;
  description: string;
  onPress: () => void;
  isActive?: boolean;
}
      </code></pre>
      <div class="callout info">
        <div class="callout-title">Documentation Tip</div>
        <p>With TypeScript, your component props are self-documenting, but additional JSDoc comments provide context and usage examples.</p>
      </div>
    </section>

    <!-- Component Library Structure Slide -->
    <section class="slide content-slide">
      <h2>Creating a Custom Component Library</h2>
      <div class="columns">
        <div class="column">
          <h3>Folder Structure</h3>
          <pre><code class="language-text">
/components
  /inputs
    CustomTextInput.tsx
    QuantitySelector.tsx
    ...
  /ui
    MedicationCard.tsx
    StatusBadge.tsx
    ...
  /layout
    Container.tsx
    Row.tsx
    Column.tsx
    ...
  /feedback
    ErrorBoundary.tsx
    LoadingOverlay.tsx
    ...
  index.ts  // Export all components</code></pre>
        </div>
        <div class="column">
          <h3>Export All Components</h3>
          <pre><code class="language-jsx">
// index.ts

// Input components
export { default as CustomTextInput } from 
  './inputs/CustomTextInput';
export { default as QuantitySelector } from 
  './inputs/QuantitySelector';

// UI components
export { default as MedicationCard } from 
  './ui/MedicationCard';
export { default as StatusBadge } from 
  './ui/StatusBadge';

// Layout components
export { default as Container } from 
  './layout/Container';
export { default as Row } from 
  './layout/Row';

// Feedback components
export { default as ErrorBoundary } from 
  './feedback/ErrorBoundary';
export { default as LoadingOverlay } from 
  './feedback/LoadingOverlay';</code></pre>
        </div>
      </div>
    </section>

    <!-- Exercise Slide -->
    <section class="slide exercise-slide">
      <h2>Exercise: Build a Pharmacy-Specific Component Library</h2>
      <p>Create a small pharmacy-specific component library with the following components:</p>
      <ol>
        <li>
          <strong>Medication List Item component</strong> showing:
          <ul>
            <li>Medication name and strength</li>
            <li>Prescription status (active, expired, etc.)</li>
            <li>Days remaining</li>
            <li>Quick action buttons (refill, details)</li>
          </ul>
        </li>
        <li>
          <strong>Dosage Scheduler component</strong> allowing:
          <ul>
            <li>Selecting time of day (morning, afternoon, evening, bedtime)</li>
            <li>Selecting frequency (daily, specific days, etc.)</li>
            <li>Displaying the next scheduled dose</li>
          </ul>
        </li>
        <li>
          <strong>Prescription Summary component</strong> showing:
          <ul>
            <li>Patient name</li>
            <li>Medication details</li>
            <li>Prescribing doctor</li>
            <li>Pharmacy location</li>
            <li>Fill history</li>
          </ul>
        </li>
      </ol>
    </section>

    <!-- Summary Slide -->
    <section class="slide summary-slide">
      <h2>Summary: Custom Components</h2>
      <ul>
        <li><strong>Component Structure:</strong> Props interface, component implementation, and styles</li>
        <li><strong>Component Types:</strong> Input components, UI components, and functional components</li>
        <li><strong>Design Principles:</strong> Single responsibility, composability, reusability, and customizability</li>
        <li><strong>Component Library:</strong> Organized structure and consistent exports</li>
      </ul>
      <div class="callout next-steps">
        <div class="callout-title">Key Takeaway</div>
        <p>Custom components allow you to build consistent, reusable UI elements that are specific to your application's needs.</p>
      </div>
    </section>

    <!-- Navigation Slide -->
    <section class="slide navigation-slide">
      <h2>Section Navigation</h2>
      <div class="navigation-buttons">
        <a href="../section-6-accessibility/index.html" class="button">← Back to Accessibility</a>
        <a href="../index.html" class="button">Module 7 Overview</a>
      </div>
    </section>
  </div>
  
  <script src="../../shared/script.js"></script>
</body>
</html>