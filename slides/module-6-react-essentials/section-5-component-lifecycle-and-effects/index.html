<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Section 5: Component Lifecycle and Effects | React Native Training Course</title>
  <link rel="stylesheet" href="../../shared/styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
  <div class="slides">
    <!-- Title Slide -->
    <section class="slide title-slide">
      <h1>Section 5</h1>
      <h2>Component Lifecycle and Effects</h2>
      <p class="metadata">Module 6 | 2 hours</p>
    </section>
    
    <!-- Learning Objectives Slide -->
    <section class="slide objectives-slide">
      <h2>Learning Objectives</h2>
      <ul>
        <li>Understand the component lifecycle in React</li>
        <li>Use the useEffect hook for side effects in functional components</li>
        <li>Handle component cleanup effectively</li>
        <li>Implement the Context API for cross-component state sharing</li>
        <li>Use additional hooks like useRef, useMemo, and useCallback for performance optimization</li>
      </ul>
      <div class="metadata">
        <p><strong>Time:</strong> 2 hours</p>
        <p><strong>Prerequisites:</strong> State and Hooks (Section 4)</p>
      </div>
    </section>
    
    <!-- Component Lifecycle Slide -->
    <section class="slide content-slide">
      <h2>The React Component Lifecycle</h2>
      <p>Every React component goes through a series of phases during its existence:</p>
      <div class="columns">
        <div class="column">
          <h3>Mounting</h3>
          <ul>
            <li>Component is being created and inserted into the DOM</li>
            <li>Constructor runs (class components)</li>
            <li>render method runs</li>
            <li>React updates the DOM</li>
            <li>componentDidMount runs (class components)</li>
            <li>useEffect with empty dependency array runs (functional components)</li>
          </ul>
        </div>
        <div class="column">
          <h3>Updating</h3>
          <ul>
            <li>Component re-renders due to changes in props or state</li>
            <li>render method runs</li>
            <li>React updates the DOM</li>
            <li>componentDidUpdate runs (class components)</li>
            <li>useEffect with dependencies runs when dependencies change (functional components)</li>
          </ul>
        </div>
        <div class="column">
          <h3>Unmounting</h3>
          <ul>
            <li>Component is being removed from the DOM</li>
            <li>componentWillUnmount runs (class components)</li>
            <li>useEffect cleanup functions run (functional components)</li>
          </ul>
        </div>
      </div>
      <div class="callout info">
        <div class="callout-title">Deep Dive</div>
        <p>Under the hood, React's reconciliation process determines when components need to re-render. This "diffing" algorithm is what makes React efficient by only updating the parts of the DOM that have changed.</p>
      </div>
    </section>
    
    <!-- Side Effects Introduction Slide -->
    <section class="slide content-slide">
      <h2>Side Effects in React</h2>
      <p>Side effects are operations that affect something outside the scope of the current function, such as:</p>
      <ul>
        <li><strong>Data Fetching</strong>: Loading data from an API</li>
        <li><strong>Subscriptions</strong>: Setting up event listeners or WebSocket connections</li>
        <li><strong>DOM Manipulation</strong>: Directly interacting with the DOM</li>
        <li><strong>Timers</strong>: Setting up intervals or timeouts</li>
        <li><strong>Logging</strong>: Recording user actions or errors</li>
      </ul>
      <div class="callout info">
        <div class="callout-title">Why Side Effects Matter</div>
        <p>React components are primarily concerned with rendering UI based on props and state. Side effects let you handle everything else that needs to happen in your application.</p>
      </div>
      <div class="callout warning">
        <div class="callout-title">Important</div>
        <p>Side effects should not be performed during rendering. React provides specific hooks and lifecycle methods to handle them properly.</p>
      </div>
    </section>
    
    <!-- The useEffect Hook Slide -->
    <section class="slide content-slide">
      <h2>The useEffect Hook</h2>
      <p>The <code>useEffect</code> hook allows you to perform side effects in functional components:</p>
      <pre><code class="language-jsx">
import React, { useState, useEffect } from 'react';
import { View, Text } from 'react-native';

function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    // This code runs after every render
    console.log('Component rendered');
    
    // Set up a timer
    const intervalId = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);
    
    // Optional cleanup function
    return () => {
      // This code runs before the component unmounts
      // or before the effect runs again
      console.log('Cleaning up timer');
      clearInterval(intervalId);
    };
  }, []); // Empty dependency array = run only on mount
  
  return (
    <View>
      <Text>Seconds: {seconds}</Text>
    </View>
  );
}
      </code></pre>
    </section>
    
    <!-- Effect Dependencies Slide -->
    <section class="slide content-slide">
      <h2>Effect Dependencies</h2>
      <p>The second argument to <code>useEffect</code> is an array of dependencies that determine when the effect should run:</p>
      <div class="columns">
        <div class="column">
          <h3>No Dependency Array</h3>
          <pre><code class="language-jsx">
// Runs after every render
useEffect(() => {
  console.log('This runs after every render');
});
          </code></pre>
        </div>
        <div class="column">
          <h3>Empty Dependency Array</h3>
          <pre><code class="language-jsx">
// Runs only after the first render (mount)
useEffect(() => {
  console.log('This runs only on mount');
}, []);
          </code></pre>
        </div>
        <div class="column">
          <h3>With Dependencies</h3>
          <pre><code class="language-jsx">
// Runs after first render and when dependencies change
useEffect(() => {
  console.log(`Current count: ${count}`);
}, [count]); // Only re-run if count changes
          </code></pre>
        </div>
      </div>
      <div class="callout warning">
        <div class="callout-title">Warning</div>
        <p>Always include all values from the component scope (props, state, etc.) that the effect uses. Missing dependencies can lead to stale closures and bugs.</p>
      </div>
    </section>
    
    <!-- Common useEffect Patterns: Data Fetching Slide -->
    <section class="slide content-slide">
      <h2>Common useEffect Pattern: Data Fetching</h2>
      <pre><code class="language-jsx">
function MedicationDetails({ medicationId }) {
  const [medication, setMedication] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    // Reset state when medicationId changes
    setIsLoading(true);
    setError(null);
    
    // Fetch data
    async function fetchMedication() {
      try {
        const response = await fetch(`/api/medications/${medicationId}`);
        if (!response.ok) throw new Error('Failed to fetch');
        const data = await response.json();
        setMedication(data);
      } catch (err) {
        setError(err.message);
      } finally {
        setIsLoading(false);
      }
    }
    
    fetchMedication();
  }, [medicationId]); // Re-run when medicationId changes
  
  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;
  if (!medication) return null;
  
  return (
    <View>
      <Text>{medication.name}</Text>
      <Text>{medication.dosage}</Text>
      {/* Additional medication details */}
    </View>
  );
}
      </code></pre>
      <div class="callout tip">
        <div class="callout-title">Best Practice</div>
        <p>Reset loading and error states whenever the dependencies change to prevent showing stale data.</p>
      </div>
    </section>
    
    <!-- Common useEffect Patterns: Subscriptions Slide -->
    <section class="slide content-slide">
      <h2>Common useEffect Pattern: Subscriptions</h2>
      <pre><code class="language-jsx">
function MedicationReminder({ patientId }) {
  const [reminders, setReminders] = useState([]);
  
  useEffect(() => {
    // Set up subscription
    const subscription = ReminderService.subscribe(patientId, (newReminders) => {
      setReminders(newReminders);
    });
    
    // Clean up subscription on unmount or when patientId changes
    return () => {
      subscription.unsubscribe();
    };
  }, [patientId]);
  
  return (
    <View>
      <Text>You have {reminders.length} medication reminders</Text>
      {reminders.map(reminder => (
        <ReminderItem key={reminder.id} reminder={reminder} />
      ))}
    </View>
  );
}
      </code></pre>
      <div class="callout highlight">
        <div class="callout-title">Important</div>
        <p>Always clean up subscriptions to prevent memory leaks. The cleanup function is crucial for preventing event listener leaks or continued network activity after a component unmounts.</p>
      </div>
    </section>
    
    <!-- Common useEffect Patterns: Timers Slide -->
    <section class="slide content-slide">
      <h2>Common useEffect Pattern: Timers</h2>
      <pre><code class="language-jsx">
function MedicationTimer({ duration, onComplete }) {
  const [timeLeft, setTimeLeft] = useState(duration);
  
  useEffect(() => {
    // Don't start if duration is invalid
    if (duration <= 0) return;
    
    // Reset timer when duration changes
    setTimeLeft(duration);
    
    // Set up interval
    const intervalId = setInterval(() => {
      setTimeLeft(prevTime => {
        if (prevTime <= 1) {
          clearInterval(intervalId);
          onComplete();
          return 0;
        }
        return prevTime - 1;
      });
    }, 1000);
    
    // Clean up interval on unmount or when duration changes
    return () => clearInterval(intervalId);
  }, [duration, onComplete]);
  
  return (
    <View>
      <Text>Time Remaining: {timeLeft} seconds</Text>
      <ProgressBar progress={(duration - timeLeft) / duration} />
    </View>
  );
}
      </code></pre>
      <div class="callout warning">
        <div class="callout-title">Warning</div>
        <p>Failing to clean up timers can lead to memory leaks and unexpected behavior. Always return a cleanup function that clears the timer.</p>
      </div>
    </section>
    
    <!-- Common useEffect Patterns: React Native-Specific Slide -->
    <section class="slide content-slide">
      <h2>React Native-Specific Effects</h2>
      <p>In React Native, you'll often use effects for platform-specific concerns:</p>
      <pre><code class="language-jsx">
import React, { useState, useEffect } from 'react';
import { View, Text, AppState } from 'react-native';

function AppStateMonitor() {
  const [appState, setAppState] = useState(AppState.currentState);
  
  useEffect(() => {
    // Set up AppState subscription
    const subscription = AppState.addEventListener('change', nextAppState => {
      console.log(`App state changed from ${appState} to ${nextAppState}`);
      setAppState(nextAppState);
    });
    
    // Clean up on unmount
    return () => {
      subscription.remove();
    };
  }, [appState]);
  
  return (
    <View>
      <Text>Current state: {appState}</Text>
      {appState === 'active' && <Text>Welcome back!</Text>}
    </View>
  );
}
      </code></pre>
      <div class="callout info platform-android platform-ios">
        <div class="callout-title">For Mobile Developers</div>
        <p>This is similar to lifecycle handling in native apps:
          <br>- Android: onResume/onPause in Activities
          <br>- iOS: applicationDidBecomeActive/applicationWillResignActive in AppDelegate</p>
      </div>
    </section>
    
    <!-- Effect Cleanup Slide -->
    <section class="slide content-slide">
      <h2>Effect Cleanup</h2>
      <p>The cleanup function (returned from an effect) is crucial for preventing memory leaks and removing resources:</p>
      <div class="columns">
        <div class="column">
          <h3>When Cleanup Runs</h3>
          <ul>
            <li>Before the component unmounts</li>
            <li>Before the effect runs again (if it has dependencies)</li>
          </ul>
        </div>
        <div class="column">
          <h3>What Should Be Cleaned Up</h3>
          <ul>
            <li>Subscriptions</li>
            <li>Timers</li>
            <li>Event listeners</li>
            <li>WebSocket connections</li>
            <li>Connections to external APIs</li>
          </ul>
        </div>
      </div>
      <pre><code class="language-jsx">
useEffect(() => {
  // Set up resource
  const subscription = someAPI.subscribe();
  
  // Clean up
  return () => {
    subscription.unsubscribe();
  };
}, [dependency]);
      </code></pre>
      <div class="callout warning">
        <div class="callout-title">Common Mistake</div>
        <p>Forgetting to clean up resources is one of the most common sources of memory leaks in React applications.</p>
      </div>
    </section>
    
    <!-- The Context API Slide -->
    <section class="slide content-slide">
      <h2>Cross-Component State with Context API</h2>
      <p>For data that needs to be accessible by many components at different levels, the Context API provides a way to share state without explicit prop passing ("prop drilling"):</p>
      <div class="columns">
        <div class="column">
          <h3>Creating Context</h3>
          <pre><code class="language-jsx">
// 1. Create a context with a default value
const UserContext = createContext(null);

// 2. Create a provider component
function UserProvider({ children }) {
  const [user, setUser] = useState(null);
  
  const login = (userData) => {
    setUser(userData);
  };
  
  const logout = () => {
    setUser(null);
  };
  
  // The value prop contains the data and functions to be shared
  return (
    <UserContext.Provider value={{ user, login, logout }}>
      {children}
    </UserContext.Provider>
  );
}
          </code></pre>
        </div>
        <div class="column">
          <h3>Consuming Context</h3>
          <pre><code class="language-jsx">
// 3. Create a custom hook for consuming the context
function useUser() {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
}

// 4. Use the context in components
function ProfileScreen() {
  const { user, logout } = useUser();
  
  if (!user) {
    return <LoginScreen />;
  }
  
  return (
    <View>
      <Text>Welcome, {user.name}</Text>
      <Button title="Logout" onPress={logout} />
    </View>
  );
}
          </code></pre>
        </div>
      </div>
    </section>
    
    <!-- Using Context Slide -->
    <section class="slide content-slide">
      <h2>Using Context Effectively</h2>
      <div class="columns">
        <div class="column">
          <h3>When to Use Context</h3>
          <ul>
            <li>User authentication state</li>
            <li>Theme settings</li>
            <li>Language preferences</li>
            <li>Feature flags</li>
            <li>Other global application state</li>
          </ul>
        </div>
        <div class="column">
          <h3>Context Limitations</h3>
          <ul>
            <li><strong>Performance</strong>: All consumers re-render when context changes</li>
            <li><strong>Component Reusability</strong>: Components that use context are tightly coupled to that context</li>
            <li><strong>Testing</strong>: Components require more setup in tests</li>
          </ul>
        </div>
      </div>
      <pre><code class="language-jsx">
// 5. Wrap your app with the provider
function App() {
  return (
    <UserProvider>
      <ThemeProvider>
        <NavigationContainer>
          {/* App components */}
        </NavigationContainer>
      </ThemeProvider>
    </UserProvider>
  );
}
      </code></pre>
      <div class="callout tip">
        <div class="callout-title">Best Practice</div>
        <p>Break your contexts into logical domains (auth, theme, etc.) rather than using a single "mega-context" for all application state.</p>
      </div>
    </section>
    
    <!-- Additional Hooks: useRef Slide -->
    <section class="slide content-slide">
      <h2>Performance Optimization: useRef</h2>
      <p>The <code>useRef</code> hook creates a mutable reference that persists across renders without causing re-renders when changed:</p>
      <pre><code class="language-jsx">
function StopWatch() {
  const [time, setTime] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef(null);
  
  // Start the stopwatch
  const start = () => {
    if (isRunning) return;
    
    setIsRunning(true);
    intervalRef.current = setInterval(() => {
      setTime(prevTime => prevTime + 1);
    }, 1000);
  };
  
  // Stop the stopwatch
  const stop = () => {
    if (!isRunning) return;
    
    clearInterval(intervalRef.current);
    intervalRef.current = null;
    setIsRunning(false);
  };
  
  // Clean up on unmount
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);
  
  return (
    <View>
      <Text>{time} seconds</Text>
      <Button title={isRunning ? "Stop" : "Start"} onPress={isRunning ? stop : start} />
    </View>
  );
}
      </code></pre>
    </section>
    
    <!-- Common useRef Use Cases Slide -->
    <section class="slide content-slide">
      <h2>Common useRef Use Cases</h2>
      <div class="columns">
        <div class="column">
          <h3>Storing Timer IDs</h3>
          <pre><code class="language-jsx">
function DelayedAlert() {
  const timerRef = useRef(null);
  
  const showAlertAfterDelay = () => {
    timerRef.current = setTimeout(() => {
      Alert.alert('Delayed message');
    }, 2000);
  };
  
  useEffect(() => {
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, []);
  
  // Component implementation
}
          </code></pre>
        </div>
        <div class="column">
          <h3>Accessing Native Elements</h3>
          <pre><code class="language-jsx">
function AutoFocusInput() {
  const inputRef = useRef(null);
  
  useEffect(() => {
    // Focus the input when component mounts
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, []);
  
  return (
    <TextInput
      ref={inputRef}
      placeholder="This will be focused"
    />
  );
}
          </code></pre>
        </div>
      </div>
      <div class="callout info">
        <div class="callout-title">Key Insight</div>
        <p>Unlike state, changes to a ref don't trigger re-renders. This makes refs ideal for storing values that need to persist between renders but don't affect the UI directly.</p>
      </div>
    </section>
    
    <!-- Additional Hooks: useMemo Slide -->
    <section class="slide content-slide">
      <h2>Performance Optimization: useMemo</h2>
      <p>The <code>useMemo</code> hook memoizes expensive calculations to avoid recomputing them on every render:</p>
      <pre><code class="language-jsx">
function MedicationAnalytics({ medications }) {
  // This expensive calculation only runs when medications change
  const analytics = useMemo(() => {
    console.log('Computing analytics...');
    
    return {
      total: medications.length,
      active: medications.filter(med => med.isActive).length,
      expired: medications.filter(med => new Date(med.expiryDate) < new Date()).length,
      byCategory: medications.reduce((acc, med) => {
        acc[med.category] = (acc[med.category] || 0) + 1;
        return acc;
      }, {})
    };
  }, [medications]); // Only recalculate when medications change
  
  return (
    <View>
      <Text>Total: {analytics.total}</Text>
      <Text>Active: {analytics.active}</Text>
      <Text>Expired: {analytics.expired}</Text>
      {/* More analytics */}
    </View>
  );
}
      </code></pre>
      <div class="callout tip">
        <div class="callout-title">When to Use</div>
        <p>Use <code>useMemo</code> when you have computationally expensive calculations that depend on props or state that don't change often.</p>
      </div>
    </section>
    
    <!-- Additional Hooks: useCallback Slide -->
    <section class="slide content-slide">
      <h2>Performance Optimization: useCallback</h2>
      <p>The <code>useCallback</code> hook returns a memoized version of a callback function that only changes when its dependencies change:</p>
      <pre><code class="language-jsx">
function MedicationList({ medications, onMedicationSelect }) {
  // This callback is stable across renders as long as onMedicationSelect doesn't change
  const handleSelect = useCallback((medication) => {
    console.log(`Selected ${medication.name}`);
    onMedicationSelect(medication);
  }, [onMedicationSelect]);
  
  return (
    <FlatList
      data={medications}
      keyExtractor={item => item.id}
      renderItem={({ item }) => (
        <MedicationItem
          medication={item}
          onSelect={() => handleSelect(item)}
        />
      )}
    />
  );
}
      </code></pre>
      <div class="callout tip">
        <div class="callout-title">When to Use</div>
        <p><code>useCallback</code> is especially important when:
          <br>- Passing callbacks to optimized child components that rely on reference equality
          <br>- Defining event handlers in components that render frequently
          <br>- Including the function in a dependency array of another hook</p>
      </div>
    </section>
    
    <!-- Custom Hooks Slide -->
    <section class="slide content-slide">
      <h2>Custom Hooks</h2>
      <p>One of the most powerful features of hooks is the ability to extract component logic into reusable functions:</p>
      <pre><code class="language-jsx">
// Custom hook for managing form state
function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  
  const handleChange = (field, value) => {
    setValues(prev => ({ ...prev, [field]: value }));
  };
  
  const handleBlur = (field) => {
    setTouched(prev => ({ ...prev, [field]: true }));
  };
  
  const reset = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };
  
  return {
    values,
    errors,
    touched,
    setErrors,
    handleChange,
    handleBlur,
    reset
  };
}

// Using the custom hook
function MedicationForm({ onSubmit }) {
  const form = useForm({
    name: '',
    dosage: '',
    schedule: 'daily'
  });
  
  // Form implementation using form.values, form.handleChange, etc.
}
      </code></pre>
    </section>
    
    <!-- Benefits of Custom Hooks Slide -->
    <section class="slide content-slide">
      <h2>Benefits of Custom Hooks</h2>
      <div class="columns">
        <div class="column">
          <h3>Reusability</h3>
          <p>Extract and share logic between components:</p>
          <pre><code class="language-jsx">
// Create a hook for fetching data
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    // Fetch implementation
  }, [url]);
  
  return { data, loading, error };
}

// Use it in multiple components
function MedicationList() {
  const { data, loading, error } = 
    useFetch('/api/medications');
  // Component implementation
}

function UserProfile() {
  const { data, loading, error } = 
    useFetch('/api/user');
  // Component implementation
}
          </code></pre>
        </div>
        <div class="column">
          <h3>Composability</h3>
          <p>Combine multiple hooks into a single custom hook:</p>
          <pre><code class="language-jsx">
function useMedicationManager() {
  // Combine multiple hooks
  const { data, loading, error } = 
    useFetch('/api/medications');
  const [filteredMeds, setFilter] = 
    useFilters(data);
  const persistence = 
    useLocalStorage('medications', data);
  
  // Additional logic
  
  return {
    medications: filteredMeds,
    loading,
    error,
    // More functions and state
  };
}
          </code></pre>
        </div>
      </div>
      <div class="callout highlight">
        <div class="callout-title">Custom Hook Rules</div>
        <p>Custom hooks must start with "use" and can call other hooks. They follow the same rules as built-in hooks.</p>
      </div>
    </section>
    
    <!-- Functional vs Class Lifecycle Slide -->
    <section class="slide content-slide">
      <h2>Functional vs. Class Component Lifecycle</h2>
      <table>
        <thead>
          <tr>
            <th>Class Component Method</th>
            <th>Functional Component Equivalent</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>constructor</code></td>
            <td><code>useState</code> initializer</td>
          </tr>
          <tr>
            <td><code>componentDidMount</code></td>
            <td><code>useEffect(() => {}, [])</code></td>
          </tr>
          <tr>
            <td><code>componentDidUpdate</code></td>
            <td><code>useEffect(() => {}, [dependencies])</code></td>
          </tr>
          <tr>
            <td><code>componentWillUnmount</code></td>
            <td><code>useEffect(() => { return () => {} }, [])</code></td>
          </tr>
          <tr>
            <td><code>shouldComponentUpdate</code></td>
            <td><code>React.memo</code> and dependency arrays</td>
          </tr>
          <tr>
            <td><code>getDerivedStateFromProps</code></td>
            <td>Compute values during render</td>
          </tr>
          <tr>
            <td><code>getSnapshotBeforeUpdate</code></td>
            <td>No direct equivalent (rarely needed)</td>
          </tr>
          <tr>
            <td><code>componentDidCatch</code></td>
            <td>Error boundaries (still class components)</td>
          </tr>
        </tbody>
      </table>
      <div class="callout info">
        <div class="callout-title">Key Difference</div>
        <p>The hook-based approach focuses on "what" side effects should happen rather than "when" they should happen in the lifecycle.</p>
      </div>
    </section>
    
    <!-- Best Practices for Effects Slide -->
    <section class="slide content-slide">
      <h2>Best Practices for Effects</h2>
      <div class="columns">
        <div class="column">
          <h3>Keep Effects Focused</h3>
          <p>Each effect should have a single responsibility. Split unrelated logic into separate effects:</p>
          <pre><code class="language-jsx">
// Good: Separate effects for different concerns
useEffect(() => {
  // Effect for handling authentication
}, [user]);

useEffect(() => {
  // Effect for handling notifications
}, [notifications]);

// Bad: Multiple unrelated concerns in one effect
useEffect(() => {
  // Handle auth and notifications in one effect
}, [user, notifications]);
          </code></pre>
        </div>
        <div class="column">
          <h3>Avoid Race Conditions</h3>
          <p>Use cleanup functions for async operations:</p>
          <pre><code class="language-jsx">
useEffect(() => {
  let isMounted = true;
  
  fetchData().then(data => {
    if (isMounted) {
      setData(data);
    }
  });
  
  return () => {
    isMounted = false;
  };
}, []);
          </code></pre>
        </div>
      </div>
      <div class="callout tip">
        <div class="callout-title">Rule of Thumb</div>
        <p>If an effect is doing too many things or has too many dependencies, it's probably a sign that it should be split into multiple effects.</p>
      </div>
    </section>
    
    <!-- Common Mistakes with useEffect Slide -->
    <section class="slide content-slide">
      <h2>Common Mistakes with useEffect</h2>
      <div class="columns">
        <div class="column">
          <h3>Missing Dependencies</h3>
          <pre><code class="language-jsx">
// Incorrect - missing 'count' dependency
useEffect(() => {
  const id = setInterval(() => {
    setCount(count + 1);
  }, 1000);
  return () => clearInterval(id);
}, []); // This will always use the initial value of count

// Correct - using functional update
useEffect(() => {
  const id = setInterval(() => {
    setCount(c => c + 1); // No dependency needed
  }, 1000);
  return () => clearInterval(id);
}, []);
          </code></pre>
        </div>
        <div class="column">
          <h3>Infinite Loops</h3>
          <pre><code class="language-jsx">
// Will cause infinite loop - effect changes dependency
useEffect(() => {
  setData(processData(data));
}, [data]);

// Unnecessary effects
// Bad - derived value doesn't need an effect
const [items, setItems] = useState([]);
const [itemCount, setItemCount] = useState(0);

useEffect(() => {
  setItemCount(items.length);
}, [items]);

// Better - compute during render
const itemCount = items.length;
          </code></pre>
        </div>
      </div>
      <div class="callout warning">
        <div class="callout-title">ESLint Plugin</div>
        <p>The <code>react-hooks/exhaustive-deps</code> ESLint rule can help catch missing dependencies and other common useEffect mistakes.</p>
      </div>
    </section>
    
    <!-- Exercise: Medication Reminder with Effects Slide -->
    <section class="slide exercise-slide">
      <h2>Exercise: Medication Reminder with Effects</h2>
      <p>Build a medication reminder component with effects:</p>
      <div class="exercise-instructions">
        <ol>
          <li>Create a component that fetches medication data from an API when it mounts</li>
          <li>Implement a timer effect that shows reminders at scheduled intervals</li>
          <li>Add an AppState listener that pauses reminders when the app is in the background</li>
          <li>Use localStorage/AsyncStorage to persist reminder settings</li>
          <li>Create at least one custom hook to abstract some of this logic</li>
        </ol>
      </div>
      <div class="callout tip">
        <div class="callout-title">Tip</div>
        <p>Pay special attention to cleanup in your effects, especially for timers and subscriptions. Test your component by mounting and unmounting it to ensure no memory leaks.</p>
      </div>
    </section>
    
    <!-- Summary Slide -->
    <section class="slide summary-slide">
      <h2>Summary: Component Lifecycle and Effects</h2>
      <ul>
        <li>The React component lifecycle consists of mounting, updating, and unmounting phases</li>
        <li>The <code>useEffect</code> hook allows you to perform side effects in functional components</li>
        <li>Effect cleanup functions are crucial for preventing memory leaks</li>
        <li>The Context API provides a way to share state across the component tree</li>
        <li>Hooks like <code>useRef</code>, <code>useMemo</code>, and <code>useCallback</code> help optimize performance</li>
        <li>Custom hooks allow you to extract and reuse component logic</li>
      </ul>
      <div class="callout next-steps">
        <div class="callout-title">Next Steps</div>
        <p>You've now completed Module 6: React Essentials! Next, you'll move on to Module 7: Components and User Input, where you'll apply these React concepts specifically to React Native development.</p>
      </div>
    </section>
    
    <!-- Module Challenge Slide -->
    <section class="slide content-slide">
      <h2>Module 6 Challenge</h2>
      <p>Now that you've completed all sections of Module 6, it's time to tackle the module challenge:</p>
      <div class="challenge-description">
        <p>Build a medication tracking component using all the concepts you've learned:</p>
        <ul>
          <li>Create a component hierarchy with parent and child components</li>
          <li>Implement state management for the medication list</li>
          <li>Use props to pass data between components</li>
          <li>Add side effects for persistence and timers</li>
          <li>Optimize performance where appropriate</li>
        </ul>
      </div>
      <div class="callout highlight">
        <div class="callout-title">Challenge Details</div>
        <p>For complete challenge instructions, refer to the Module 6 Challenge document in the course materials.</p>
      </div>
    </section>
    
    <!-- Navigation Slide -->
    <section class="slide navigation-slide">
      <h2>Section Navigation</h2>
      <div class="navigation-buttons">
        <a href="../section-4-state-and-hooks/index.html" class="button">‚Üê Previous: State and Hooks</a>
        <a href="../index.html" class="button">Back to Module 6 Overview</a>
      </div>
    </section>
  </div>
  
  <script src="../../shared/script.js"></script>
</body>
</html> 